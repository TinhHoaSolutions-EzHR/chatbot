"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8130],{77735:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"donut","metadata":{"permalink":"/blog/donut","source":"@site/blog/2024-11-22-Development-guide.mdx","title":"donut.c without a math library","description":"My little donut.c has been making the rounds again, after being featured in a couple YouTube videos (e.g., Lex Fridman and Joma Tech). If I had known how much attention this code would get over the years, I would have spent more time on it.","date":"2024-11-22T00:00:00.000Z","tags":[{"inline":false,"label":"Donut","permalink":"/blog/tags/blog/donut/","description":"Donut related posts"}],"readingTime":7.435,"hasTruncateMarker":false,"authors":[{"name":"Le Kiet","title":"Software Engineer | Data Scientist","page":{"permalink":"/blog/authors/lekiet"},"url":"https://github.com/lekiet1214/","socials":{"github":"https://github.com/lekiet1214","x":"https://x.com/lekiet0101"},"imageURL":"https://avatars.githubusercontent.com/u/50958432?v=4","key":"lekiet"},{"name":"Andy Sloane","title":"A very cool person","page":{"permalink":"/blog/authors/a-1-k-0-n"},"url":"https://www.a1k0n.net/","socials":{"github":"https://github.com/a1k0n","x":"https://x.com/a1k0n"},"imageURL":"https://pbs.twimg.com/profile_images/1276550107597434880/zQiDj5nM_400x400.jpg","key":"a1k0n"}],"frontMatter":{"title":"donut.c without a math library","date":"2024-11-22T00:00:00.000Z","authors":["lekiet","a1k0n"],"tags":["donut"],"slug":"donut"},"unlisted":false},"content":"<head>\\n\\n<script src=\\"https://www.a1k0n.net/js/donut2.js\\"><\/script>\\n<script type=\\"text/javascript\\" async=\\"\\" src=\\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\\"><\/script>\\n</head>\\n\\nMy little [donut.c](https://www.a1k0n.net/2011/07/20/donut-math.html) has been making the rounds again, after being featured in a couple YouTube videos (e.g., [Lex Fridman](https://www.youtube.com/watch?v=DEqXNfs_HhY) and [Joma Tech](https://www.youtube.com/watch?v=sW9npZVpiMI)). If I had known how much attention this code would get over the years, I would have spent more time on it.\\n\\nOne thing that\u2019s always been sort of unfortunate is the heavy use of sin and cos \u2013 both because it necessitates linking the math library (-lm), but also because it makes it much more CPU-intensive than it really needs to be. This is especially apparent if you try to port it to an [older CPU](https://twitter.com/chainq/status/1297178062937825280) or an [embedded device](https://twitter.com/enjoy_digital/status/1341095343816118272).\\n\\nSo, here\u2019s a revised version with no use of sin, cos, and no need for linking the math library (though this version still does use float types).\\n\\n```\\n            i,j,k,x,y,o,N;\\n         main(){float z[1760],a\\n      #define R(t,x,y) f=x;x-=t*y\\\\\\n   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;\\n   =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char\\n b[1760];for(;;){memset(b,32,1760);g=0,\\nh=1;memset(z,0,7040);for(j=0;j<90;j++){\\nG=0,H=1;for(i=0;i<314;i++){A=h+2,D=1/(G*\\nA*a+g*e+5);t=G*A        *e-g*a;x=40+30*D\\n*(H*A*d-t*c);y=          12+15*D*(H*A*c+\\nt*d);o=x+80*y;N          =8*((g*a-G*h*e)\\n*d-G*h*a-g*e-H*h        *c);if(22>y&&y>\\n 0&&x>0&&80>x&&D>z[o]){z[o]=D;b[o]=(N>0\\n  ?N:0)[\\".,-~:;=!*#$@\\"];}R(.02,H,G);}R(\\n  .07,h,g);}for(k=0;1761>k;k++)putchar\\n   (k%80?b[k]:10);R(.04,e,a);R(.02,d,\\n     c);usleep(15000);printf(\'\\\\n\'+(\\n        \\" donut.c! \\\\x1b[23A\\"));}}\\n          /*no math lib needed\\n             .@a1k0n 2021.*/\\n```\\nIt\u2019s a little misshapen and still has comments at the bottom. I used the first frame of its output as a template and there\u2019s slightly less code than filled pixels \u2013 oh well. Output is pretty much the same as before:\\n\\n```\\n                                 @@@$$$$$$@@@@                                \\n                              $$$$#############$$$$                            \\n                           #####***!*!!!!!!*****###$$#                         \\n                         ####**!!!!!!!====!!!!!!***#####                       \\n                        ##****!!!==;;::::::;;==!!!!***##*                      \\n                       ****!!!==;;:~-,,,,,--~::;==!!******                     \\n                      ****!!!==::~-.........,-~:;==!!*****!                    \\n                     =!**!!!==;:-,............,~:;==!!****!                    \\n                     !!**!!!==;~-,..        ..,-:;==!!****!=                   \\n                     =!!*!!!!=;:~,.          .,~;==!!!!*!!!=                   \\n                     ;!!!***!!!!=;~          ~:;;==!!!!!!!!;                   \\n                     ;=!!********!!=        ;=!!*!!***!!!!=;                   \\n                     :=!!!***#########**!**##*********!!!=;~                   \\n                      :=!!****###$$$@@@@$$$$$$####***!!!=;:                    \\n                       :;!!****###$$$@@@@@$$$$###**!!!!=;~                     \\n                        ~;=!!!***####$$$$$$####**!!!!=;:~                      \\n                         -~;=!!*******####******!!!=;:~,                       \\n                           -~:==!!!*!****!**!!!!==;:~.                         \\n                              ,~~:;;;=======;;;:~-.                            \\n                                 ..,--------,,.     \\n```\\n\\n## Defining a rotation\\nSo, how do we get sines and cosines without using `sin` and `cos`? Well, the code doesn\u2019t really *need* sine and cosine *per se*; what it actually does is rotate a point around the origin in two nested loops, and also rotate two angles just for the animation. If you\u2019ll recall from the other article, the inner loop is just plotting dots in a circle, which goes around another, larger circle. In each loop, the sine/cosine terms are just moving by a small, fixed angle.\\n\\nSo we don\u2019t need to track the *angle* at all, we only need to start at cos=1, sin=0 and rotate a circle around the origin to generate all the sines and cosines we need. We just have to repeatedly apply a fixed rotation matrix:\\n\\n$$\\n\\\\begin{bmatrix}\\nc\' \\\\\\\\\\ns\'\\n\\\\end{bmatrix}\\n=\\n\\\\begin{bmatrix}\\n\\\\cos \\\\theta & -\\\\sin \\\\theta \\\\\\\\\\n\\\\sin \\\\theta & \\\\cos \\\\theta\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\nc \\\\\\\\\\ns\\n\\\\end{bmatrix}\\n$$\\n\\nSo for example, if we were to use an angle of .02 radians in our inner loop, it would look something like:\\n\\n```c\\nfloat c=1, s=0;  // c for cos, s for sin\\nfor (int i = 0; i < 314; i++) {  // 314 * .02 ~= 2\u03c0\\n  // (use c, s in code)\\n  float newc = 0.9998*c - 0.019998666*s;\\n  s = 0.019998666*c + 0.9998*s;\\n  c = newc;\\n}\\n```\\n\\n## Renormalizing\\n\\nThat works, but there\u2019s a problem: no matter how precisely we define our constants, after repeated iteration of this procedure, the magnitude of our $(c,s)$ vector will exponentially grow or shrink over time. If we only need to make one pass around the loop, maybe we can get away with that, but if we have to make several (for the rotating animation, we do), we need to fix that.\\n\\n\\n<figure><img src=\\"https://www.a1k0n.net/img/sincos-mag.png\\"alt=\\"an exaggerated illustration of what happens when repeatedly doing low-precision rotations\\"></img><figcaption><em>an exaggerated illustration of what happens when repeatedly doing low-precision rotations</em></figcaption></figure>\\n\\nThe simplest way to do that would be to multiply $c$ and $s$ by $\\\\frac{1}{\\\\sqrt{c^2 + s^2}}$, but then we\u2019re back to using the math library again. Instead, we can take advantage of the fact that our magnitude starts out very close to 1, and we\u2019re going to be iterating this procedure: we can do a [Newton step](https://en.wikipedia.org/wiki/Newton%27s_method) after each rotation, and that will be enough to keep the magnitude \u201cclose enough\u201d to 1 over time.\\n\\nThe simplest way to do that would be to multiply $`c`$ and $`s`$ by $\\\\frac{1}{\\\\sqrt{c^2 + s^2}}$, but then we\u2019re back to using the math library again. Instead, we can take advantage of the fact that our magnitude starts out very close to 1, and we\u2019re going to be iterating this procedure: we can do a Newton step after each rotation, and that will be enough to keep the magnitude \u201cclose enough\u201d to 1 over time.\\n\\nOur goal is to find the reciprocal square root (sound familiar?) of \\n$$\\na = c^2 + s^2\\n$$\\n, our $(c, s)$ vector magnitude. Say we define a function\\n$$\\nf(x) = \\\\frac{1}{x^2} - a\\n$$\\n\\nThe function is 0 when \\n$$\\nx = \\\\frac{1}{\\\\sqrt{a}}\\n$$\\n\\nWe can start with an initial guess of 1 for `x`, perform a Newton iteration to obtain `x\'`, which will be \u201ccloser to\u201d \\n\\n$$\\n\\\\frac{1}{\\\\sqrt{a}}\\n$$\\n\\nthe correct value to scale `c` and `s` by so that their magnitude \\n\\n$$\\nc^2 + s^2\\n$$\\n\\nis \u201cclose to\u201d 1 again.\\n\\nA Newton step is defined as:\\n\\n$$\\nx\' = x - \\\\frac{f(x)}{f\'(x)}\\n$$\\n\\nI used SymPy to do the derivative and simplification and came up with:\\n\\n\\n$$\\nx\' = x \\\\cdot \\\\frac{3 - a x^2}{2}\\n$$\\n\\nSince we\u2019re only doing one step, we can plug in our initial guess of 1 for `x` and back-substitute\\n$$\\nc^2 + s^2\\n$$\\n\\nfor `a` to finally get our adjustment:\\n\\n$$\\nx\' = \\\\frac{3 - (c^2 + s^2)}{2}\\n$$\\n\\n## Further simplifying the rotation\\nBut now that we don\u2019t have to worry so much about the magnitude of our result (within limits), we can take another shortcut (I got this idea studying old [CORDIC](https://en.wikipedia.org/wiki/CORDIC) algorithms). If we divide out the cosines from our original rotation matrix, we get\\n\\n$$\\n\\n\\\\begin{bmatrix}\\nc\' \\\\\\\\\\ns\'\\n\\\\end{bmatrix}\\n=\\n\\\\frac{1}{\\\\cos\\\\theta}\\n\\\\begin{bmatrix}\\n1 & \\\\tan\\\\theta \\\\\\\\\\n-\\\\tan\\\\theta & 1\\n\\\\end{bmatrix}\\n\\\\begin{bmatrix}\\nc \\\\\\\\\\ns\\n\\\\end{bmatrix}\\n\\n$$\\n\\nusing the trig identity \\n\\n$$\\ntan\u03b8=sin\u03b8cos\u03b8\\n$$\\n\\nSince we\u2019re only dealing with small angles, the leading $\\\\frac{1}{\\\\cos0}$ term is close enough to 1 that we can ignore it and have our Newton step take care of it.\\nAnd now we can finally understand how the rotation is done in the code. Towards the top of the donut code is this #define, which I\u2019ve reindented:\\n\\n```c\\n#define R(t,x,y) \\\\ \\n  f = x; \\\\\\n  x -= t*y; \\\\\\n  y += t*f; \\\\\\n  f = (3-x*x-y*y)/2; \\\\\\n  x *= f; \\\\\\n  y *= f;\\n```\\n\\nThis does an in-place rotation of a unit vector `x, y` where `t` is `tan\u03b8`. `f` is a temporary variable; the first three lines do the \u201cmatrix multiplication\u201d on `x, y`. `f` is then re-used to get the magnitude adjustment, and then finally `x` and `y` are multiplied by f which moves them back onto the unit circle.\\n\\nWith that operation in hand, I just replaced all the angles with their sines and cosines and ran the rotation operator `R()` instead of calling `sin/cos`. The code is otherwise identical.\\n\\n## Getting rid of `float`, too\\n\\nWe can use exactly the same ideas with integer fixed-point arithmetic, and not use any `float` math whatsoever. I\u2019ve redone all the math with 10-bit precision and produced the following C code which runs well on embedded devices which can do 32-bit multiplications and have ~4k of available RAM:\\n\\n```C\\n#include <stdint.h>\\n#include <stdio.h>\\n#include <string.h>\\n#include <unistd.h>\\n\\n#define R(mul,shift,x,y) \\\\\\n  _=x; \\\\\\n  x -= mul*y>>shift; \\\\\\n  y += mul*_>>shift; \\\\\\n  _ = 3145728-x*x-y*y>>11; \\\\\\n  x = x*_>>10; \\\\\\n  y = y*_>>10;\\n\\nint8_t b[1760], z[1760];\\n\\nvoid main() {\\n  int sA=1024,cA=0,sB=1024,cB=0,_;\\n  for (;;) {\\n    memset(b, 32, 1760);  // text buffer\\n    memset(z, 127, 1760);   // z buffer\\n    int sj=0, cj=1024;\\n    for (int j = 0; j < 90; j++) {\\n      int si = 0, ci = 1024;  // sine and cosine of angle i\\n      for (int i = 0; i < 324; i++) {\\n        int R1 = 1, R2 = 2048, K2 = 5120*1024;\\n\\n        int x0 = R1*cj + R2,\\n            x1 = ci*x0 >> 10,\\n            x2 = cA*sj >> 10,\\n            x3 = si*x0 >> 10,\\n            x4 = R1*x2 - (sA*x3 >> 10),\\n            x5 = sA*sj >> 10,\\n            x6 = K2 + R1*1024*x5 + cA*x3,\\n            x7 = cj*si >> 10,\\n            x = 40 + 30*(cB*x1 - sB*x4)/x6,\\n            y = 12 + 15*(cB*x4 + sB*x1)/x6,\\n            N = (-cA*x7 - cB*((-sA*x7>>10) + x2) - ci*(cj*sB >> 10) >> 10) - x5 >> 7;\\n\\n        int o = x + 80 * y;\\n        int8_t zz = (x6-K2)>>15;\\n        if (22 > y && y > 0 && x > 0 && 80 > x && zz < z[o]) {\\n          z[o] = zz;\\n          b[o] = \\".,-~:;=!*#$@\\"[N > 0 ? N : 0];\\n        }\\n        R(5, 8, ci, si)  // rotate i\\n      }\\n      R(9, 7, cj, sj)  // rotate j\\n    }\\n    for (int k = 0; 1761 > k; k++)\\n      putchar(k % 80 ? b[k] : 10);\\n    R(5, 7, cA, sA);\\n    R(5, 8, cB, sB);\\n    usleep(15000);\\n    printf(\\"\\\\x1b[23A\\");\\n  }\\n}\\n```\\n\\nThe output is pretty much the same as before, but now it\u2019s running on a 32-bit microcontroller with no floating-point unit."}]}}')}}]);